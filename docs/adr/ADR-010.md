# ADR-010: Vector Index — sqlite-vec vs hnswlib

**Decision:** Use sqlite-vec for vector indexing instead of hnswlib. Keep vectors in the same SQLite database as field indexes.

**Rationale:**
- sqlite-vec keeps vectors in the same database as field indexes — one file, one connection, one transaction model
- No separate index files to manage, backup, or sync
- Pure C with zero dependencies — compiles everywhere SQLite compiles (Linux, macOS, Windows, WASM, Raspberry Pi)
- MKB targets single-user/small-team use cases (likely <100K documents) where sqlite-vec's brute-force search is "fast enough"
- Simpler mental model: all data lives in SQLite, indexes are derived and rebuildable from vault files
- Python and Rust can both access the same sqlite-vec index — no FFI bridging required

**Evaluation:**

| Criterion | sqlite-vec | hnswlib |
|-----------|-----------|---------|
| **Simplicity** | ✓✓✓ Single SQLite database, loadable extension | ✗ Separate index files, external dependency |
| **Performance (100K vectors)** | ✓ Brute-force ~15-60K queries/sec, good enough for <100K docs | ✓✓ HNSW graph ~60K+ queries/sec with better scaling |
| **Rust ecosystem** | ✓✓ Native SQLite bindings (rusqlite) | ✓ Multiple crates (hnswlib-rs, hnsw_rs), fragmented ecosystem |
| **Persistence** | ✓✓✓ SQLite database file, ACID transactions | ✓ Custom binary format, manual save/load |
| **Build complexity** | ✓✓✓ Pure C, compiles with SQLite | ✓ C++ library, requires build toolchain |
| **Python interop** | ✓✓✓ Same sqlite-vec extension in Python | ✓ hnswlib has Python bindings, but separate index |
| **Maturity** | ✓ v0.1.0 stable release (Aug 2024), actively maintained by Alex Garcia | ✓✓ Battle-tested since 2016, widely used in production |
| **Quantization** | ✓✓ Binary quantization support for compression | ✓ No built-in quantization |
| **ANN indexing** | ✗ No approximate nearest neighbors (brute-force only) | ✓✓ HNSW graph structure for efficient ANN |

**Performance Details:**

- sqlite-vec: Benchmarks show 15-60K queries/sec on GIST1M dataset, outperformed Faiss and usearch in static mode query times
- hnswlib (hnsw_rs crate): 62K req/s on fashion-mnist (recall 0.977), 15K req/s on sift1m (recall 0.9907)
- For <100K documents at 1536 dimensions, sqlite-vec's brute-force is sufficient for interactive query latency

**Key Trade-off:**

We're choosing simplicity and integration over raw performance. sqlite-vec won't scale to millions of vectors like hnswlib, but MKB's target use case (single-user, small-team knowledge bases) rarely exceeds 100K documents.

**Migration Path:**

If a user outgrows sqlite-vec (hundreds of thousands of documents, slow queries), we can:
1. Add hnswlib as an optional backend via feature flag
2. Provide `mkb index migrate --backend hnswlib` command
3. Keep sqlite-vec as the default for simplicity

**Implementation Notes:**
- Use rusqlite with sqlite-vec loadable extension
- Store vectors in SQLite table: `CREATE VIRTUAL TABLE vec_index USING vec0(embedding float[1536])`
- Rebuild index with `mkb index rebuild --vectors` (same pattern as field indexes)
- Python tooling uses same sqlite-vec extension via sqlite3 module

**Consequences:**
- One less external dependency, simpler build and deployment
- All indexes (field + vector) rebuild from vault files with single command
- Easier to backup: single SQLite file contains everything
- Performance ceiling at ~100K documents, but acceptable for target use case
- If we need to scale later, we can add hnswlib as opt-in backend without breaking API
